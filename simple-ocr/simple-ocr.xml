<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://web-harvest.sourceforge.net/schema/1.0/config" scriptlang="groovy">

	<!-- 
		Name: Simple OCR 
		Author: @veselink1 (Veselin Karaganev)
		Version: 0.2.1
	-->

    <!-- BEGIN CONFIGURATION -->

    <!-- the input document URL -->
    <var-def name="ocr_input" overwrite="false">
        <!-- <var name="original_document_url" /> -->
        http://aa-materials.s3.amazonaws.com/Materials/ML_Auto/PDFs/Document-01.pdf
    </var-def>

    <!-- comma-separated list of up to 3 formats (one of: txt, html, xml, xmlForCorrectedImage) -->
    <var-def name="ocr_export_format" overwrite="false">
        html,xml
    </var-def>

    <!-- comma-separated list of languages (default: English) -->
    <var-def name="ocr_language" overwrite="false">
        English
    </var-def>
    
    <!-- the name of the cache datastore (default: simple_ocr_cache) -->
    <var-def name="ocr_cache_datastore" overwrite="false">
       	simple_ocr_cache
    </var-def>
    
    <!-- the name of the cache bucket (default: doc-upload) -->
    <var-def name="ocr_cache_bucket" overwrite="false">
        doc-upload
    </var-def>
    
    <!-- the path in the cache bucket (default: ocr) -->
    <var-def name="ocr_cache_key" overwrite="false">
        ocr
    </var-def>
    
    <!-- whether to correct skew or not (default: true) -->
    <var-def name="ocr_correct_skew" overwrite="false">
        true
    </var-def>
    
    <!-- whether to correct orientation or not (default: true) -->
    <var-def name="ocr_correct_orientation" overwrite="false">
        true
    </var-def>
    
    <!-- a list of custom regions in JSON format (default: empty) -->
    <var-def name="ocr_custom_regions" overwrite="false">
        <!-- Example: [{"page":1,"left":0,"top":0,"right":800,"bottom":600, "type":"BT_Text" }] -->
        []
    </var-def>

    <!-- whether to ues only custom regions or not (default: false) -->
    <var-def name="ocr_use_only_custom_regions" overwrite="false">
        false
    </var-def>
    
    <!-- comma-separated list of allowed region types (default: empty; one of: BT_Table,BT_Text,BT_Barcode,BT_VectorPicture,BT_RasterPicture) -->
    <var-def name="ocr_allowed_region_types" overwrite="false">
    	
    </var-def>
    
    <!-- the total time in seconds to wait for the OCR to complete (default: 300 = 5 minutes) -->
    <var-def name="ocr_timeout" overwrite="false">
        300
    </var-def>
    
    <!-- the total time in seconds to wait for a status query to complete (default: 10) -->
    <var-def name="ocr_completion_polling_timeout_seconds" overwrite="false">
        10
    </var-def>
    
    <!-- the total time in seconds between sequential status queries (default: 15) -->
    <var-def name="ocr_completion_polling_interval_seconds" overwrite="false">
        15
    </var-def>

    <!-- remove garbage (excess dots that are smaller than a certain size) from the image (default: -1 (automatic)) -->
    <var-def name="ocr_remove_garbage_size" overwrite="false">
        -1
    </var-def>
    
    <!-- END CONFIGURATION -->

	<!-- 
		OCR Plugin Documentation: https://kb.workfusion.com/display/WF/OCR+Plugin
	-->

  	<var-def name="ocr_document">
    	<http url="${ocr_input}"/>
  	</var-def>
    <var-def name="ocr_document_hash">
    	<script return="org.apache.commons.codec.digest.DigestUtils.md5Hex(ocr_document.toBinary())"/>
 	</var-def>
    
    <create-datastore name="${ocr_cache_datastore}">
    	<datastore-column name="md5" />
    	<datastore-column name="format" />
    	<datastore-column name="link" />
	</create-datastore>
  
    <script><![CDATA[ 
    	sql_format_list = ocr_export_format.toString().split(',').collect{ it -> "'${it}'" }.join(',') 
    ]]></script>
    
    <var-def name="cache_lookup_result">
      <datastore name="${ocr_cache_datastore}">
   		<template>
          SELECT (format, link) FROM @this 
          	WHERE md5 = '${ocr_document_hash}'
            	AND format IN (${sql_format_list});
        </template>
      </datastore>
    </var-def>
    
    <script><![CDATA[
       	// If not all formats are cached, we can just invoke OCR with all the formats. 
       	// ABBY's pricing model counts number of documents, not formats. 
       	List<String> cachedFormats = cache_lookup_result.wrappedObject.collect { it.get('format') }
       	List<String> exportFormats = ocr_export_format.toList()
    	/* global */ is_cached = exportFormats.every { cachedFormats.contains(it) }
    ]]></script>
  
    <var-def name="ocr_results" />
    
  	<case>
      <if condition="${is_cached}">
      	<script><![CDATA[
            List<Map> results = []
            for (def row : cache_lookup_result.wrappedObject) {
            	results << [
            		format: row.get("format"), 
            		link: row.get("link")
            	]
            }
            
		  	sys.defineVariable('ocr_results', results)
        ]]></script>
      </if>
      <else>
        <var-def name="raw_ocr_results">
            <ocr 
                 export-format="${ocr_export_format}"
                 language="${ocr_language}"
                 correct-skew="${ocr_correct_skew}"
                 correct-orientation="${ocr_correct_orientation}"
                 custom-regions="${ocr_custom_regions}"
                 allowed-region-types="${ocr_allowed_region_types}"
                 remove-garbage-size="${ocr_remove_garbage_size}"
                 timeout="${ocr_timeout}"
                 completion-polling-timeout-seconds="${ocr_completion_polling_timeout_seconds}"
                 completion-polling-interval-seconds="${ocr_completion_polling_interval_seconds}">
              <ocr-image>
                <var name="ocr_document" />
              </ocr-image>
            </ocr>
        </var-def>
        
        <script><![CDATA[
        	String getExtForFormat(String format) {
        		switch (format) {
        			case "txt": return "txt";
        			case "html": return "html";
        			case "xml": return "xml";
        			case "xmlForCorrectedImage": return "xml";
        			case "pdfSearchable": return "pdf";
        		}
        		throw new RuntimeException("Unrecognized OCR export format '${format}'!")
        	}
        
        	/* global */ ocr_result_items = []
	        raw_ocr_results.get(0).wrappedObject.results.each { format, data -> 
	          	if (!data) {
	          		throw new RuntimeException("Converting '${ocr_input}' to '${format}' failed! The OCR plugin returned '${data}'!")
	          	}
	          	
	          	ocr_result_items << [
	          		format: format, 
	          		data: data, 
	          		extension: getExtForFormat(format)
	          	]
	        }
        ]]></script>
        
        <var-def name="ocr_result_links">
	        <s3 bucket="${ocr_cache_bucket}">
		        <loop item="ocr_result_item">
		        	<list><script return="ocr_result_items" /></list>
		        	<body>
		        		<s3-put 
			        		path="${ocr_cache_key}/${UUID.randomUUID()}.${ocr_result_item.wrappedObject.extension}" 
			        		content-type="application/octet-stream"
			        		content-disposition="inline">
		        			<script return="ocr_result_item.wrappedObject.data" />
        				</s3-put>
		        	</body>
		        </loop>
	        </s3>
        </var-def>
        
        <script><![CDATA[
          def gson = new com.google.gson.Gson();
          List<String> formatsInCache = cache_lookup_result.wrappedObject.collect { it.get("format") }
          
          int index = 0;
          List<Map> results = ocr_result_items.collect { item -> 
        
          		format: item.format, 
          		link: ocr_result_links[index++].toString()
          	]
          };
          
          /* global */ jsonValueMaps = []
          results.each { item -> 
          	if (!formatsInCache.contains(item.format)) {
          	  jsonValueMaps << gson.toJson([
                md5: ocr_document_hash.toString(), 
                format: item.format, 
                link: item.link
              ])
             }
          }
          
		  sys.defineVariable('ocr_results', results)
        ]]></script>
          
        <loop item="jsonValueMap">
        	<list><script return="jsonValueMaps" /></list>
          	<body>
            	<insert-datastore datastore-name="${ocr_cache_datastore}" json-value-map="${jsonValueMap}" />
          	</body>
        </loop>
      </else>
    </case>
    
    <script><![CDATA[
    	sys.defineVariable('ocr_result_indices', (0..<ocr_results.size()).toList())
    ]]></script>

    <export include-original-data="true">
		<loop item="ocr_result_index">
			<list><script return="ocr_result_indices" /></list>
			<body>
				<single-column 
					name="ocr_export_${ocr_results[ocr_result_index.toInt()].wrappedObject.format}" 
					value="${ocr_results[ocr_result_index.toInt()].wrappedObject.link}" />
			</body>
		</loop>
    </export>

</config>